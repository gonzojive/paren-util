(in-package :paren-util)

;(defmacro global (symbol-like)
;  "Use this to call a reference global variable."
;  (let ((string (typecase symbol-like
;		  (string symbol-like)
;		  (symbol (symbol-name symbol-like))
;		  (t (error "Expected string or symbole but got ~S" symbol-like)))))
;    `',(intern string :js-global)))

(defun equal (a b)
  (return (=== a b)))

(defun eql (a b)
  (return (== a b)))

(defun identity (thing)
  (return thing))

(defun to-array (array-like)
  (let ((result-arr (array)))
    (dolist (arg array-like)
      (methcall 'js-global::push result-arr arg))
    (return result-arr)))

(defun lispy-map (func arg1)
  (with-arguments-array (arguments-arr)
    (let ((result-arr (array))
	  (ith-from-each-arg (lambda (i)
			       (return
				 (methcall 'js-global::map
					   (methcall 'js-global::slice arguments-arr 1)
					(lambda (arg) (return (slot-value arg i))))))))
      (dotimes (index (slot-value arg1 'js-global::length))
	(methcall
	 'js-global::push
	 result-arr
	 (methcall 'js-global::apply func nil (ith-from-each-arg index))))
      (return result-arr))))

(defun merge-into (receiving-obj &rest donating-objs)
  (dolist (other-obj donating-objs)
    (for-in (prop other-obj)
	    (setf (slot-value receiving-obj prop)
		  (aref other-obj prop))))
  (return receiving-obj))

(defun length (arr)
  (return (slot-value arr 'js-global::length)))

(defun subseq (arr start &optional end)
  "Just like subseq in lisp."
  (return (methcall 'js-global::splice (copy-array arr) start (or end (length arr)))))
  

(defun lispy-apply (func &rest rest)
  "Similar to lisp's apply method.  Takes a predicate, an object that serves as the 'this'
object for each function application, and then several arguments.  The last argument is
appended to the ..."
  (let ((std-args (methcall 'js-global::splice rest
			    0 
			    (- (slot-value rest 'js-global::length)
			       1)))
	(last (aref rest (- (slot-value rest 'js-global::length) 1))))
    (return
      (methcall 'js-global::apply func
		this
		(if last 
		    (methcall 'js-global::concat std-args last)
		    std-args)))))

(defun collect (fun arr)
  (let ((passing-members (array)))
    (dolist (member arr)
      (if (fun member)
	  (methcall 'js-global::push passing-members member)))
    (return passing-members)))

(defun find (desired-item arr &key (key thing) (test equal))
  (when arr
    (dolist (item arr)
      (when (funcall test desired-item (funcall key item))
	(return item))))
  (return nil))

(defvar remove-if-not collect)

(defun every (fun arr)
  (dolist (member arr)
    (if (not (fun member))
	(return false)))
  (return true))

(defun some (fn arr)
  (dolist (item arr)
    (let ((result (fn item)))
      (when result
	(return result))))
  (return false))

(defun identity (i)
  (return i))

(defun find (item sequence &key (key identity) (test equal))
  (dolist (member sequence)
    (when (funcall test item (funcall key member))
      (return member)))
  (return nil))

(defun push-on-end (obj place)
  (return (methcall 'js-global::push place obj)))

(defun remove (item sequence &key (key identity) (test equal))
  (let ((result (array)))
    (dolist (member sequence)
      (when (not (funcall test item (funcall key member)))
	(push-on-end member result)))
    (return result)))

(defun key-object-to-array (obj)
  "Converts an object like {foo : 'bar'} into an array like ['foo', 'bar'] ..."
  (let ((result (array)))
    (when obj
      (for-in (key obj)
	      (methcall 'js-global::push result key)
	      (methcall 'js-global::push result (slot-value obj key))))
    (return result)))

(defun keys-array-fn-to-key-object-fn (fn num-non-keyword-args)
  "Creates a function that accepts NUM-NON-KEYWORD-ARG # of normal and optional arguments, and
then a key-object parameter (a generic object that's keys/values are keyword arguments to the
function) from a normal defun-ed function."
  (return (lambda (&rest args)
	    (let ((transformed-args (methcall 'js-global::concat
					      (subseq args 0 num-non-keyword-args)
					      (key-object-to-array (elt args num-non-keyword-args)))))
	      (log "Transformed args / args")
	      (log transformed-args)
	      (log args)
	      
	      (return (methcall 'js-global::apply fn js-global:this transformed-args))))))
		      
				

;; implement Javascript 1.6 methods ourselves
(defaultf (slot-value js-global::-Array :prototype :map)
    (lambda (fn)
      (let ((result (array)))
	(dolist (item js-global:this)
	  (methcall 'js-global::push result (fn item)))
	(return result))))

(defaultf (slot-value js-global::-Array :prototype :index-of)
    (lambda (sought &optional (from-index 0))
      (let ((index 0))
	(dolist (item js-global:this)
	  (when (and (>= index from-index) (=== item sought))
	    (return index))
	  (incf index 1))
	(return -1))))


(defaultf (slot-value js-global::-Array :prototype :filter)
    (lambda (fun)
      (return (collect fun js-global:this))))

(defaultf (slot-value js-global::-Array :prototype :every)
    (lambda (fun)
      (return (every fun js-global:this))))

(defaultf (slot-value js-global::-Array :prototype :some)
    (lambda (fun)
      (return (some fun js-global:this))))

; this isn't pretty but it works
(defun remove-duplicates (in-arr &optional (equality-lambda eql))
  "Removes duplicates in the given array using the given equality function, which defaults
to a strict === comparison."
  (let ((working-array in-arr)
	(out-arr (array)))
    (while t
      (if (== 0 (slot-value working-array 'js-global::length))
	  (break)
	  (let ((latest-unique-item (slot-value working-array 0)))
	    (methcall 'js-global::push out-arr latest-unique-item)
	    (setf working-array 
		  (methcall 'js-global::filter working-array 
			    (lambda (test-item)
			      (return (not (equality-lambda
					    test-item latest-unique-item)))))))))
    (return out-arr)))

(defun lexicographic-compare (a b)
  "Compares to strings lexicographically, returning negative if a < b, 0 if a = b, and positive
if a > b.  Ignores case and treats `9' < `80'."
  ;; at this point I have forgotten what a true lexicographic compare is and I'm pretty sure
  ;; that this isn't it
  (let ((str-a (methcall 'js-global::to-lower-case a))
	(str-b (methcall 'js-global::to-lower-case b)))
    (let ((rv (if (< str-a str-b) -1 (if (> str-a str-b) 1 0))))
      (return rv))))

(defun ajax-request (url &key on-success on-failure on-loading on-loaded on-interactive (method :get))
  (let* ((ready-state nil)
	 (transport (or (and (slot-value js-global:window :-x-m-l-http-request)
			     (new (js-global::-x-m-l-http-request)))
			(and (slot-value js-global:window :-active-x-object)
			     (or (new (js-global::-active-x-object "Msxml2.XMLHTTP"))
				 (new (js-global::-active-x-object "Microsoft.XMLHTTP"))))))
	 (method (methcall :to-upper-case method))
	 (on-rsc-fn (lambda ()
		      (setf ready-state (slot-value transport :ready-state))
		      (when (=== 4 ready-state)
			(funcall on-success (slot-value transport :response-text) transport)))))
    (setf (slot-value transport :onreadystatechange) on-rsc-fn)
    (methcall :open transport method url t)
    (methcall :send transport nil)))
    
(defun object-to-keyargs (obj)
  (let ((arr (array)))
    (for-in (key obj)
	    (methcall :push arr key)
	    (methcall :push arr (slot-value obj key)))
    (return arr)))

(defun escape-html (str)
  ;; stolen from prototype
  (let ((div (methcall :create-element js-global:document "div"))
	(text (methcall :create-text-node js-global:document str)))
    (methcall :append-child div text)
    (return (slot-value div :inner-h-t-m-l))))

(defun elem-by-id (id)
  (let ((result nil))
    (cond
      ((slot-value document :get-element-by-id)
       (return (paren-util:methcall :get-element-by-id document id))))))

(defun remove-elem (elem)
  (let ((parent-elem (slot-value elem 'js-global::parent-node)))
    (methcall 'js-global::remove-child
	      parent-elem
	      elem)))

(defun remove-from-array (arr item)
  (let ((index (methcall 'js-global::index-of arr item)))
    (when (!== -1 index)
      (methcall 'js-global::splice arr index 1))))

(defun copy-array (arr)
  (let ((result (array)))
    (dolist (item arr)
      (methcall :push result item))
    (return result)))

;;; UI-oriented

;; show/hide elements
(defun elem-visible? (elem)
  "Returns t if the element is not hidden"
  (return (!== "none" (slot-value elem 'js-global::style 'js-global::display))))

(defun elem-hide (elem)
  "Hides the element."
  (setf (slot-value elem 'js-global::style 'js-global::display) "none"))

(defun elem-show (elem)
  "Unhides the element."
  (setf (slot-value elem 'js-global::style 'js-global::display) ""))

;; page size calculation
(defun calculate-framep ()
  "Returns true if the javascript context is inside a frame."
  (return
    (and (slot-value js-global:window 'js-global::parent 'js-global::frames
		     (slot-value js-global:window 'js-global::name))
	 (<= (length (methcall 'js-global::get-elements-by-tag-name
			       (slot-value js-global::parent 'js-global:document)
			       "frameset"))
	     0))))

(defun toplevel-window ()
  "Returns the toplevel window regardless of framesets and so on."
  (let* ((framep (calculate-framep))
	 (win (if framep js-global::parent js-global::self)))
    (return win)))

(defun calculate-page-scroll ()
  "Returns an array of length 2 with the x and y scroll."
  (let* ((framep (calculate-framep))
	 (doc (if framep (slot-value js-global::parent 'js-global:document) js-global:document))
	 (win (if framep js-global::parent js-global::self))
	 (doc-elem (slot-value doc 'js-global::document-element)))
    (return (array
	     (or (slot-value win 'js-global::page-x-offset)
		 (slot-value doc 'js-global::body 'js-global::scroll-left)
		 (and doc-elem (slot-value doc-elem 'js-global::scroll-left))
		 0)
	     (or (slot-value win 'js-global::page-y-offset)
		 (slot-value doc 'js-global::body 'js-global::scroll-top)
		 (and doc-elem (slot-value doc-elem 'js-global::scroll-top))
		 0)))))
    

(defun calculate-max-page-scroll ()
  "Returns an array of length 2 with the x and y scroll."
  (let* ((framep (calculate-framep))
	 (doc (if framep (slot-value js-global::parent 'js-global:document) js-global:document))
	 (win (if framep js-global::parent js-global::self))
	 (doc-elem (slot-value doc 'js-global::document-element)))
    (cond
      ((and (slot-value js-global:window 'js-global::inner-height)
	    (slot-value js-global:window 'js-global::scroll-max-y))
       (log "first")
       (return (array (slot-value js-global:window 'js-global::scroll-max-x)
		      (+ (if framep
			     (slot-value js-global::parent 'js-global::inner-height)
			     (slot-value js-global::self 'js-global::inner-height))
			 (if framep
			     (slot-value js-global::parent 'js-global::scroll-max-y)
			     (slot-value js-global::self 'js-global::scroll-max-y))))))
      ((> (slot-value doc 'js-global::body 'js-global::scroll-height)
	  (slot-value doc 'js-global::body 'js-global::offset-height))
       (log "second")
       (return (array (slot-value doc 'js-global::body 'js-global::scroll-width)
		      (slot-value doc 'js-global::body 'js-global::scroll-height))))
      (t
       (log "third")
       (let* ((html-elem (methcall 'js-global::item
				   (methcall 'js-global::get-elements-by-tag-name doc "html")
				   0))
	      (ow (slot-value html-elem 'js-global::offset-width))
	      (oh (slot-value html-elem 'js-global::offset-height))
	      (body-ow (slot-value doc 'js-global::body 'js-global::offset-width))
	      (body-oh (slot-value doc 'js-global::body 'js-global::offset-width)))
	 (return (array (if (< ow body-ow) body-ow ow)
			(if (< oh body-oh) body-oh oh))))))))

(defun calculate-window-size ()
  "Returns an array of length 2 with the size of the window in pixels."
  (let* ((framep (calculate-framep))
	 (relevant-window (if framep js-global::parent js-global::self))
	 (doc (if framep (slot-value js-global::parent 'js-global:document) js-global:document)))
    
    (cond
      ((slot-value js-global::self 'js-global::inner-height)
       (return (array (slot-value relevant-window 'js-global::inner-width)
		      (slot-value relevant-window 'js-global::inner-height))))
      ((and (slot-value js-global::document 'js-global::document-element)
	    (slot-value js-global::document 'js-global::document-element 'js-global::client-height))
       (let ((doc-elem (slot-value doc 'js-global::document-element)))
	 (return (array (slot-value doc 'js-global::client-width)
			(slot-value doc 'js-global::client-height)))))
      ((slot-value js-global::document 'js-global::body)
       (let* ((html-elem (methcall 'js-global::item
				   (methcall 'js-global::get-elements-by-tag-name doc "html")
				   0))
	      (win-width (slot-value html-elem 'js-global::client-width))
	      (win-height (slot-value html-elem 'js-global::client-height)))
	 (return (array (if (=== 0 win-width)
			    (slot-value doc 'js-global::body 'js-global::client-width)
			    win-width)
			(if (=== 0 win-height)
			    (slot-value doc 'js-global::body 'js-global::client-height)
			    win-height))))))))
      
(defun calculate-page-size ()
  (let* ((scroll (calculate-max-page-scroll))
	 (x-scroll (elt scroll 0))
	 (y-scroll (elt scroll 1))
	 (size (calculate-window-size))
	 (window-width (elt size 0))
	 (window-height (elt size 1))
	 (page-height (if (< y-scroll window-height)
			  window-height
			  y-scroll))
	 (page-width (if (< x-scroll window-width)
			 window-width
			 x-scroll)))
    (return (array page-width page-height
		   window-width window-height
		   x-scroll y-scroll))))

;; element or html insertion
;;;; HTML/JS utility
(defvar *tag-table*
  (create "TABLE" (array "<table>" "</table>" 1)
	  "TBODY" (array "<table><tbody>" "</tbody></table>" 2)
	  "TR" (array "<table><tbody><tr>" "</tr></tbody></table>" 3)
	  "TD" (array "<table><tbody><tr><td>" "</td></tr></tbody></table>" 4)
	  "SELECT" (array "<select>" "</select>" 1)))

(defvar *attribute-translations*
  (create "class" "className"
	  "for" "htmlFor"))

(defvar *internet-explorer*
  (and (slot-value js-global:window :attach-event) (not (slot-value js-global:window :operate)) t))

(defun insertion-fn (location)
  "Returns a function of two arguments--an element and a DOM node--that will insert the DOM node into the page :before, :after
at the :top or :bottom of the element."
  (let ((result nil))
    (case location
      (:before (setf result (lambda (element node)
			      (methcall :insert-before (slot-value element :parent-node)  node element))))
      (:after (setf result  (lambda (element node)
			      (methcall :insert-before (slot-value element :parent-node)   node (slot-value element :next-sibling)))))
      (:top (setf result  (lambda (element node)
			    (methcall :insert-before element node (slot-value element :first-child)))))
      (:bottom (setf result (lambda (element node)
			      (methcall :append-child element node)))))
    (return result)))

(defun write-attributes (elem attributes)
  "Given a hash table of attributes and a dom element, sets the attributes of the element
according to the attribute names."
  (for-in (attr attributes)
	  (let ((name (or (slot-value *attribute-translations* attr) attr))
		(value (slot-value attributes attr)))
	    (cond
	      ((or (=== false value) (=== nil value))       (methcall :remove-attributes elem name))
	      ((=== true value) (methcall :set-attribute elem name name))
	      (t (methcall  :set-attribute elem name value)))))
  (return elem))

(defun create-elem (tag-name &optional (attributes-obj (create)))
  "Creates a DOM element with the given tag name and attributes."
  (setf tag-name (methcall :to-lower-case tag-name))
  (when (and *internet-explorer* (slot-value attributes-obj :name))
    (setf tag-name (+ "<" tag-name " name=\"" (slot-value attributes-obj :name) "\">"))
    (delete (slot-value attributes-obj :name)))
  
  (let ((elem (methcall :create-element js-global:document tag-name)))
    (write-attributes elem attributes-obj)
    (return elem)))

(defun unescape-html (str)
  (let  ((node (create-elem "DIV")))
    (setf (slot-value node 'js-global::inner-h-t-m-l)
	  str)
    (cond
      ((slot-value node 'js-global::inner-text)
       (return (slot-value node 'js-global::inner-text)))
      ((slot-value node 'js-global::inner-content)
       (return (slot-value node 'js-global::inner-content)))
      (t (return str)))))

(defun html-content-to-dom-nodes (html-content tag-name)
  "Given some HTML content, inserts it into an anonymous element with the given tag-name (e.g. 'DIV', 'TABLE'),
and returns an array of elements."
;  (parn-psos::log  (+ "Converting HTML " html-content " to DOM nodes in tag with name " tag-name))
  (let* ((div (create-elem "div"))
	 (tag (slot-value *tag-table* (methcall :to-upper-case tag-name))))
    (if tag
	(progn
	  (setf (slot-value div :inner-h-t-m-l) (+ (aref tag 0) html-content (aref tag 1)))
	  (dotimes (i (aref tag 2))
	    (setf div (slot-value div :first-child))))
	 (setf (slot-value div :inner-h-t-m-l) html-content))
    (return (to-array (slot-value div :child-nodes)))))

(defun stringp (thing)
  (return (=== "string" (ps:typeof thing))))

(defun elem-insert (elem content location)
  "Location is one of :top :bottom :before :after.  Content is an html string."
  (let* ((insert-fn (insertion-fn location))
	 (insert-elem-tag-name (slot-value (if (or (== :before location) (== :after location))
					       (slot-value elem :parent-node)
					       elem)
					   :tag-name))
	 (content-nodes (if (stringp content)
			    (html-content-to-dom-nodes content insert-elem-tag-name)
			    (array content))))
    (when (or (=== :top location) (=== :after location))
      (methcall :reverse content-nodes))

    (lispy-map (lambda (content-node)
		 (insert-fn elem content-node))
	       content-nodes)))